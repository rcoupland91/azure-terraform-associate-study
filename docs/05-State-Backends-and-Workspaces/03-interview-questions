# SECTION 10 â€” Senior-Level Terraform Interview Questions
*(The ones that separate the pros from the juniors)*


### 1. Why does Terraform need state?
<details>
<summary>ğŸ” Show Answer</summary>

To keep a real-time mapping between your config and actual cloud resources so it knows exactly what changed and what to create/update/delete during `plan`/`apply`.

</details>

### 2. How do you fix infrastructure drift?
<details>
<summary>ğŸ” Show Answer</summary>

Run `terraform plan` to detect it, then either `apply` to enforce the desired state **or** update your code to match reality (and optionally `terraform refresh` / `refresh-only`).

</details>

### 3. What is the benefit of a remote backend?
<details>
<summary>ğŸ” Show Answer</summary>

Centralized state storage, state-file versioning, and most importantly â€” **state locking** so two people donâ€™t corrupt state at the same time.

</details>

### 4. What happens if someone deletes a resource manually in Azure?
<details>
<summary>ğŸ” Show Answer</summary>

Terraform sees itâ€™s missing during the next `plan` and will happily recreate it on `apply` (because desired state > reality).

</details>

### 5. How do you import an existing Blob Storage Account?
<details>
<summary>ğŸ” Show Answer</summary>

Write the `azurerm_storage_account` resource block first, then run:  
```hcl
resource "azurerm_storage_account" "demo" {
  name = "my-sa-name"
}
```
```bash
terraform import azurerm_storage_account.demo my-sa-name
```

Remember: Import moves real world â†’ state file.
</details>

### 6. What is state locking?
<details>
<summary>ğŸ” Show Answer</summary>

A safety mechanism (usually handled by the remote backend) that prevents multiple Terraform runs from modifying the state file simultaneously and causing corruption.

</details>

